import Condition from "./Condition";
import { Sorter } from "./Sorter";
import { QueryExecutorInterface } from "./QueryExecutorInterface";
import { DataServiceResponseInterface } from "../DataService";
export default class Query<T> {
    protected _from: string;
    protected _offset: number;
    protected _limit: number;
    protected _fields: string[];
    protected _conditions: Condition[];
    protected _sorters: Sorter[];
    protected _includes: string[];
    protected _find: any;
    protected _executor: QueryExecutorInterface;
    constructor(executor?: QueryExecutorInterface);
    executor(executor: QueryExecutorInterface): Query<T>;
    getExecutor(): QueryExecutorInterface;
    hasExecutor(): boolean;
    from(from: string): Query<T>;
    getFrom(): string;
    hasFrom(): boolean;
    field(field: string): Query<T>;
    addManyFields(fields: string[]): Query<T>;
    getFields(): string[];
    hasFields(): boolean;
    offset(offset: number): Query<T>;
    getOffset(): number;
    hasOffset(): boolean;
    limit(limit: number): Query<T>;
    getLimit(): number;
    hasLimit(): boolean;
    condition(condition: Condition): Query<T>;
    multipleConditions(conditions: Condition[]): Query<T>;
    getConditions(): Condition[];
    hasConditions(): boolean;
    sorter(sorter: Sorter): Query<T>;
    multipleSorters(sorters: Sorter[]): Query<T>;
    getSorters(): Sorter[];
    hasSorters(): boolean;
    include(include: string): Query<T>;
    multipleIncludes(includes: string[]): Query<T>;
    getIncludes(): string[];
    hasIncludes(): boolean;
    find(id: any): Query<T>;
    getFind(): any;
    hasFind(): boolean;
    execute(): ng.IPromise<DataServiceResponseInterface<T>>;
    merge(query: Query<T>): Query<T>;
    serialize(opts: string[]): string;
    static from(from: any): Query<{}>;
    toObject(): any;
    static fromObject<T>(obj: any): Query<T>;
}
